# juc学习

- 版本java version "1.8.0_231"

## 基础

### 一、概念

用户线程：自定义线程 （普通线程），主线线程，用户线程还在运行，jvm存活。

守护线程：比如垃圾回收gc线程，没有用户线程都是守护线程，jvm结束。（setDaem（true）设置为守护线程在start（）之前）



### 二、thread状态

#### 1.1状态转化图

![3756800208-5c1b354a84566](../files/assets/3756800208-5c1b354a84566.jpg)

#### **2.1. 初始状态(NEW)**

实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。

#### **2.2. 就绪状态(RUNNABLE之READY)**

1. 就绪状态只是说你资格运行，调度程序(**Cpu**)没有挑选到你，你就永远是就绪状态。
2. 调用线程的start()方法，此线程进入就绪状态。
3. 当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。
4. 当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。
5. 锁池里的线程拿到对象锁后，进入就绪状态。

#### **2.3. 运行中状态(RUNNABLE之RUNNING)**

线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一的一种方式。

#### **2.4. 阻塞状态(BLOCKED)**

阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。

#### 2.5. 等待**(WAITING)**

处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。

#### 2.6. 超时等待**(TIMED_WAITING)**

处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。

#### **2.7. 终止状态(TERMINATED)**

1. 当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。
2. 在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。

### 

