1、string和stringbuffer的区别
string是不可改的，并且其类型是final的，也不进行集成。
而stringbuffer可以理解成是一个工具类，其内部虽然也是char数据，但是对象
表示的字符串是可以进行修改的。
2、线程的wait和notify作用
wait是和锁对象绑定的，使用waite，将会使线程进入该锁对象的等待队列，同时
线程将会放弃对cpu的使用请求。
而notify是用来唤醒锁对象的等待队列中的线程的，使其重新被cpu调度，执行后续逻辑。
3、was容器 宕机的处理
首先登陆服务器，查看进程是否还在。
如果进程还在则尝试打开was管理页面，看was能否登陆，若可以登录，则看其中的应用运行状态，若运行状态也是正常
则可能是服务器哪里产生了性能瓶颈，故可通过top、free命令查看系统的cpu、内存使用情况。
若之前的操作都没有用则可以查看was运行日志，进一步分析原因。
4、was容器 目录结构，配置
5、数据库什么操作会造成锁
6、实现数据库锁的方式
乐观锁：给对应数据添加字段，例如1，每次修改+1，在进行修改之前查询改字段，在进行update的时候判断该字段值是否还是这个。
悲观锁：对要进行修改的数据在查询时添加for update.使其能进行
7、代码块的锁
8、存储过程和视图
9、三大范式
(1)字段不可再分
(2)表必须要有主键，并且其它字段必须要与主键全部对应，不能对应主键的一部分。
(3)其它字段必须要直接与主键关联，而不能通过其它字段简介与主键关联。
10、事务acid四个原则
atom 原子性    要么全部成功，要么全部失败
consistency 一致性 事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态(需进一步理解)
isolation 隔离型   事务对数据的修改其它事务不可见
durability  持久性  事务提交完成之后，数据永久保存在磁盘中，不会因服务器宕机而丢失。
11、事务是什么
我：事务是一系列sql的操作的总集
正确答案：是对数据库操作的最小单位，是一些sql操作的总集，这些操作要么全部提交，要么全部不提交。
12、数据库的优化方式有哪些、数据库sql调优
(1)优化硬件
(2)代码优化
(3)添加索引： 单字段索引、联合索引、前缀索引
(3)sql优化  ：
我：
	      建表时将主键最好设置成数字类型。
	select语句方面:在字段前面使用表别名，减少解析逻辑以加快速度。
	from语句方面：对于关联查询比较频繁的表，可将频繁使用的字段冗余至另一张表，或者建立视图
	where语句方面：多使用索引字段进行查询；因为函数与计算会全表扫描，所以尽量少使用函数；查询条件有多个的时候可以在将索引列的条件放在其他条件左边；in尽量少用，用的时候可以将可能性大条件放在前面。
		          or最好用join替换。尽量不要使用null，相比空串会加大存储空间，并且会是索引失效。
答案：
https://blog.csdn.net/qq_38789941/article/details/83744271
一个表的索引数最好不要超过6个
很多时候用 exists 代替 in 是一个好的选择
使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。		        
不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
应尽量避免在 where 子则将引擎放弃使用索引而进行全表扫描。
任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段
(4)数据库配置方式优化  例如：读写分离，添加查询缓存
13、新需求的数据库建表设计方案
梳理逻辑，确定实体管理
根据实体关系，并依据范式进行表初步设计
规划表命名方式
分析需求，可针对某些情况进行字段冗余
字段类型尽量选择数字，字符串用可变长类型varchar
根据表结构设计索引
14、left join，right join，union，子查询和多表查询
left join 以左边的数据为依据，右边没有置空
right join 以右边的数据为依据，左边没有置空
子查询 select where中

15、sleep和wait的区别
	sleep占用cpu，wait不占用内存
	sleep有时长
16、索引

17、spring事务实现方式有几种，你是怎么实现的   
1、通过注解 <tx:annotation-driven transaction-manager="tracnsactionManager"/>  若没有transaction-manager，则自动取org.springframework.jdbc.datasource.DataSourceTransactionManager的bean对象
2、直接使用dataSource对象获取Connection手动开启事务执行sql提交事务
3、通过配置文件配置切入点(<aop:pointcust expression ='execution(* *com.xx.xx.UserDao.deleteUser(..))'>)。
<aop:config>
		<!-- 切入点配置 -->
		<aop:pointcut id="point" expression="execution(* *constxiong.interview.transaction.UserDao.deleteUser(..))" />
		<aop:advisor advice-ref="txAdvice" pointcut-ref="point"/>
	</aop:config>
4、通过jdbcTmplate+transactionManager


18、多线程和线程池  
自己实现：
1 : 线程池管理器(ThreadPool) : 用于创建并管理线程池,包括创建线程池,销毁线程池,添加新任务;

2 : 工作线程( PoolWorder ) : 线程池中线程,在没有任务时处于等待状态,可以循环的执行任务;

3 :  任务接口( Task) : 每个任务必须实现的接口,以供工作线程调度任务的执行,它主要规定了任务的入口,任务执行完后的收尾工作,任务的执行状态等;

4 : 任务队列(taskQueue) : 用于存放没有处理的任务.提供一种缓存机制.
利用spring自带进行配置。org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor

threadlocal而是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据
java多线程中的原子性、可见性、有序性
     （1）、原子性：是指线程的多个操作是一个整体，不能被分割，要么就不执行，要么就全部执行完，中间不能被打断。
     （2）、可见性：是指线程之间的可见性，就是一个线程修改后的结果，其他的线程能够立马知道。
     （3）、有序性：为了提高执行效率，java中的编译器和处理器可以对指令进行重新排序，重新排序会影响多线程并发的正确性，有序性就是要保证不进行重新排序（保证线程操作的执行顺序）。
看到这里就知道了一些基本区别，volatile保证了可见性和有序性（不保证原子性）但是synchronized保证了可见性和有序性的同时还保证了原子性。
（1）、volatile只能作用于变量，使用范围较小。synchronized可以用在变量、方法、类、同步代码块等，使用范围比较广。
（2）、volatile只能保证可见性和有序性，不能保证原子性。而可见性、有序性、原子性synchronized都可以包证。
（3）、volatile不会造成线程阻塞。synchronized可能会造成线程阻塞。
19、Java设计模式   
创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。

结构型模式：把类或对象结合在一起形成一个更大的结构。

行为型模式：类和对象如何交互，及划分责任和算法。

单例模式，它的定义就是确保某一个类只有一个实例，并且提供一个全局访问点。

单例模式具备典型的3个特点：1、只有一个实例。 2、自我实例化。 3、提供全局访问点。

 因此当系统中只需要一个实例对象或者系统中只允许一个公共访问点，除了这个公共访问点外，不能通过其他访问点访问该实例时，可以使用单例模式。

单例模式的主要优点就是节约系统资源、提高了系统效率，同时也能够严格控制客户对它的访问。也许就是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，所以扩展起来有一定的困难
作为抽象工厂模式的孪生兄弟，工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。

工厂方法模式非常符合“开闭原则”，当需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须修改原有系统。同时在工厂方法模式中用户只需要知道生产产品的具体工厂即可，无须关系产品的创建过程，甚至连具体的产品类名称都不需要知道。虽然他很好的符合了“开闭原则”，但是由于每新增一个新产品时就需要增加两个类，这样势必会导致系统的复杂度增加
所谓抽象工厂模式就是提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。他允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。这样一来，客户就可以从具体的产品中被解耦。它的优点是隔离了具体类的生成，使得客户端不需要知道什么被创建了，而缺点就在于新增新的行为会比较麻烦，因为当添加一个新的产品对象时，需要更加需要更改接口及其下所有子类

 代理模式就是给一个对象提供一个代理，并由代理对象控制对原对象的引用。它使得客户不能直接与真正的目标对象通信。代理对象是目标对象的代表，其他需要与这个目标对象打交道的操作都是和这个代理对象在交涉。

代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了的作用和保护了目标对象的，同时也在一定程度上面减少了系统的耦合度。
策略模式包含如下角色：
Context: 环境类
Strategy: 抽象策略类
ConcreteStrategy: 具体策略类
20、谈谈消息中间件原理  
21、Redis使用场景简单说一下
22、开发一个新项目你是怎么打算的
23、抽象类和接口的异同点
24、jvm，java为啥能跨平台，java的垃圾回收机制产生原因及强制使用是否立即生效
25、框架升级过程及原因，为啥要升级，有哪些好处以及便利之处
26、多线程的几种方式，最常用哪个，有什么好处，线程池
27、jdk，jre，jvm的区别
28、重载和重写
29、在项目中遇到的困难
30、Springboot核心注解
@SpringBootApplication
用于Spring主类上最最最核心的注解，自动化配置文件，表示这是一个SpringBoot项目，用于开启SpringBoot的各项能力。相当于@SpringBootConfigryation、@EnableAutoConfiguration、@ComponentScan三个注解的组合。
@Configuration

Spring 3.0添加的一个注解，用来代替applicationContext.xml配置文件，所有这个配置文件里面能做到的事情都可以通过这个注解所在的类来进行注册。
@ComponentScan

Spring 3.1添加的一个注解，用来代替配置文件中的component-scan配置，开启组件扫描，自动扫描包路径下的@Component注解进行注册bean实例放到context(容器)中。
@Import

Spring 3.0添加注解，用来导入一个或者多个@Configuration注解修饰的配置类。

@IMportReSource

Spring 3.0添加注解，用来导入一个或者多个Spring配置文件，这对Spring Boot兼容老项目非常有用，一位内有些配置文件无法通过java config的形式来配置

31、还有springboot的启动方式
32、Springboot是否可以单独启动 不需要容器
可以，spring的start依赖中内置了tomcat
33、hashmap与LinkedHashMap区别
HashMap 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力。
LinkedHashMap LinkedHashMap也是一个HashMap,但是内部维持了一个双向链表,可以保持顺序

说一下Springboot，为什么要用Springboot

进程与线程

Java静态绑定和动态绑定
当子类和父类（接口和实现类）存在同一个方法时，子类重写父类（接口）方法时，程序在运行时调用的方法时，是调用父类（接口）的方法呢？还是调用子类的方法呢？我们将确定这种调用何种方法的操作称之为绑定。
?绑定又分为静态绑定和动态绑定。
 
静态绑定
静态绑定是在程序执行前就已经被绑定了(也就是在程序编译过程中就已经知道这个方法是哪个类中的方法)。
springboot 优势、核心注解
spring 依赖注入，依赖注入实现方式
springcloud 主要组件和作用
mybatis 比spring jdbc 有什么优势
Java、arrayList优缺点

Java 反射在spring中的应用
spring哪一块是基于反射实现的
依赖注入

linkedhashmap和hashmap区别
linkedhashmap是维护了双向链表，是有序的，hashmap是无序的


跨域访问
jsonp
整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。
浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。
因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

Java 动态代理、Java反射、Java静态绑定和动态绑定

linux常用命令

内存溢出的情况
排查其实最主要的就是检查代码，而且内存溢出往往都是代码的问题。当然一下几点都是需要注意的：
（1）内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
（2）集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
（3）代码中存在死循环或循环产生过多重复的对象实体；
（4）使用的第三方软件中的BUG；
（5）启动参数内存值设定的过小；
第一步，修改JVM启动参数，直接增加内存。
第二步，检查错误日志
第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。


遇到过的生产问题、如何分析及定位问题
先恢复服务，然后初步判断，检查日志，复现问题，修改BUG，测试上线。

mysql分页方式
实际可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式。
（limit,索引，子查询）

rocket 消息丢失
生产者产生消息发送给RocketMQ，
RocketMQ接收到了消息之后，必然需要存到磁盘中，否则断电或宕机之后会造成数据的丢失
消费者从RocketMQ中获取消息消费，消费成功之后，整个流程结束